// Fluid2D.compute — stable fluids + dye OR optical-depth pigment

#pragma kernel Advect
#pragma kernel ComputeDivergence
#pragma kernel Jacobi
#pragma kernel SubtractGradient
#pragma kernel ApplyBrush
#pragma kernel AdvectDye

#define TX 8
#define TY 8

cbuffer SimParams : register(b0)
{
    float2 invResolution;   // 1/width, 1/height
    float  dt;              // delta time
    float  dissipation;     // velocity decay [0..1]
    float  dyeDissipation;  // dye/τ decay [0..1]
    float  gridScale;       // usually 1

    float2 brushPos;        // uv 0..1
    float2 brushVel;        // uv/sec * strength
    float  brushRadius;     // pixels
    float4 brushColor;      // RGBA

    uint   applyBrush;      // 0/1
    float  vorticityStrength; // (reserved)
    uint   usePigment;      // 0=RGB dye, 1=optical-depth pigment τ
    float  pigmentStrength; // τ added per stroke unit (0.05–0.3 good)
}

Texture2D<float2>   _VelocityRead;
RWTexture2D<float2> _VelocityWrite;

Texture2D<float>    _PressureRead;
RWTexture2D<float>  _PressureWrite;

RWTexture2D<float>  _Divergence;

Texture2D<float4>   _DyeRead;      // if pigment: stores τ (optical depth) in .rgb
RWTexture2D<float4> _DyeWrite;

float2 ClampUV(float2 uv) {
    return clamp(
        uv,
        float2(0.5 * invResolution.x, 0.5 * invResolution.y),
        1.0 - float2(0.5 * invResolution.x, 0.5 * invResolution.y)
    );
}

float3 RGB_to_CMY(float3 rgb) { return 1.0 - rgb; }

// ---- 1) Advect velocity ----
[numthreads(TX, TY, 1)]
void Advect(uint3 id : SV_DispatchThreadID)
{
    uint2 coord = id.xy;
    float2 uv = (float2(coord) + 0.5) * invResolution;

    float2 v = _VelocityRead[coord];
    float2 prevUV = ClampUV(uv - v * dt * invResolution * gridScale);
    float2 vPrev = _VelocityRead[uint2(prevUV / invResolution)];
    _VelocityWrite[coord] = vPrev * dissipation;
}

// ---- 2) Compute divergence ----
[numthreads(TX, TY, 1)]
void ComputeDivergence(uint3 id : SV_DispatchThreadID)
{
    uint2 c = id.xy;
    uint W = (uint)round(1.0 / invResolution.x);
    uint H = (uint)round(1.0 / invResolution.y);

    uint2 L = uint2(max(int(c.x) - 1, 0), c.y);
    uint2 R = uint2(min(c.x + 1, W - 1), c.y);
    uint2 B = uint2(c.x, max(int(c.y) - 1, 0));
    uint2 T = uint2(c.x, min(c.y + 1, H - 1));

    float2 vL = _VelocityRead[L];
    float2 vR = _VelocityRead[R];
    float2 vB = _VelocityRead[B];
    float2 vT = _VelocityRead[T];

    float dx = 0.5 * (vR.x - vL.x);
    float dy = 0.5 * (vT.y - vB.y);
    _Divergence[c] = dx + dy;
}

// ---- 3) Jacobi pressure solve ----
[numthreads(TX, TY, 1)]
void Jacobi(uint3 id : SV_DispatchThreadID)
{
    uint2 c = id.xy;
    uint W = (uint)round(1.0 / invResolution.x);
    uint H = (uint)round(1.0 / invResolution.y);

    uint2 L = uint2(max(int(c.x) - 1, 0), c.y);
    uint2 R = uint2(min(c.x + 1, W - 1), c.y);
    uint2 B = uint2(c.x, max(int(c.y) - 1, 0));
    uint2 T = uint2(c.x, min(c.y + 1, H - 1));

    float pL = _PressureRead[L];
    float pR = _PressureRead[R];
    float pB = _PressureRead[B];
    float pT = _PressureRead[T];
    float div = _Divergence[c];

    _PressureWrite[c] = (pL + pR + pB + pT - div) * 0.25;
}

// ---- 4) Subtract pressure gradient ----
[numthreads(TX, TY, 1)]
void SubtractGradient(uint3 id : SV_DispatchThreadID)
{
    uint2 c = id.xy;
    uint W = (uint)round(1.0 / invResolution.x);
    uint H = (uint)round(1.0 / invResolution.y);

    uint2 L = uint2(max(int(c.x) - 1, 0), c.y);
    uint2 R = uint2(min(c.x + 1, W - 1), c.y);
    uint2 B = uint2(c.x, max(int(c.y) - 1, 0));
    uint2 T = uint2(c.x, min(c.y + 1, H - 1));

    float pL = _PressureRead[L];
    float pR = _PressureRead[R];
    float pB = _PressureRead[B];
    float pT = _PressureRead[T];

    float2 v = _VelocityRead[c];
    float2 grad = 0.5 * float2(pR - pL, pT - pB);
    _VelocityWrite[c] = v - grad;
}

// ---- 5) Apply brush ----
[numthreads(TX, TY, 1)]
void ApplyBrush(uint3 id : SV_DispatchThreadID)
{
    if (applyBrush == 0) return;

    uint2 coord = id.xy;
    float2 brushPx = brushPos / invResolution;
    float2 d = float2(coord) - brushPx;
    float falloff = exp(-dot(d, d) / (brushRadius * brushRadius)); // Gaussian
    float s = saturate(falloff);

    // velocity impulse
    float2 v = _VelocityRead[coord] + brushVel * s;
    _VelocityWrite[coord] = v;

    // dye / pigment
    float4 c = _DyeRead[coord];

    if (usePigment == 0)
    {
        // RGB dye: simple lerp toward brushColor
        _DyeWrite[coord] = lerp(c, brushColor, s);
    }
    else
    {
        // Optical-depth pigment: store τ (optical thickness) in RGB
        // τ accumulates linearly; later display uses exp(-density * τ)
        float3 tau = c.rgb;
        float3 brushPig = RGB_to_CMY(brushColor.rgb); // CMY pigments
        tau += pigmentStrength * s * brushPig;

        // Soft clamp so repeated strokes don't nuke to black instantly.
        // τ in [0, ~6] covers from transparent to ~e^-6 ≈ 0.002 transmission.
        tau = clamp(tau, 0.0, 6.0);

        _DyeWrite[coord] = float4(tau, 1.0);
    }
}

// ---- 6) Advect dye/τ ----
[numthreads(TX, TY, 1)]
void AdvectDye(uint3 id : SV_DispatchThreadID)
{
    uint2 coord = id.xy;
    float2 uv = (float2(coord) + 0.5) * invResolution;

    float2 v = _VelocityRead[coord];
    float2 prevUV = ClampUV(uv - v * dt * invResolution * gridScale);
    float4 cPrev = _DyeRead[uint2(prevUV / invResolution)];
    _DyeWrite[coord] = cPrev * dyeDissipation;
}
