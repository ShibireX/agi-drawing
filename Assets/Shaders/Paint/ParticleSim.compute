#pragma kernel Integrate

struct Particle {
    float4 position; // xyz, w = radius
    float4 velocity; // xyz, w = age   (age < 0 => dead)
    float4 color;    // rgb, w = alpha
};

RWStructuredBuffer<Particle> _Particles;
RWStructuredBuffer<uint>     _SpawnedCount; // length = 1

int   _ActiveCount;      // we will set this to particleCount from CPU
float _DeltaTime;
float _Gravity;
float _Damping;
float _AirResistance;   // drag coefficient
float3 _BoundsExtents;
float _MaxInitialSpeed;
float _LifeTime;
float _FadeOutDuration;  // how long before death to start fading
float _SpawnRadius;      // radius to assign on spawn
float _SpreadAngle;      // cone spread angle in radians
float _ForwardBias;      // 0 to 1, how much to bias towards forward direction
int   _EmitEnabled;      // 0/1
int   _SpawnBudget;      // max spawns allowed this frame

float3 _SpawnPosition;
float3 _SpawnDirection;
float3 _SpawnColor;
float3 _ForwardDirection; // preferred launch direction (towards canvas)

float3 _PrevSpawnPosition;
float3 _PrevSpawnDirection;

uint Hash(uint seed) {
    seed ^= 2747636419u;
    seed *= 2654435769u;
    seed ^= seed >> 16;
    seed *= 2654435769u;
    seed ^= seed >> 16;
    seed *= 2654435769u;
    return seed;
}
float Random01(uint seed) { return (Hash(seed) & 0x00FFFFFF) / 16777216.0f; }

float3 RandomDirection(uint seed)
{
    float x = Random01(seed * 3u) * 2 - 1;
    float y = Random01(seed * 5u) * 2 - 1;
    float z = Random01(seed * 7u) * 2 - 1;
    float3 d = float3(x, y, z);
    return (all(d == 0)) ? float3(0,1,0) : normalize(d);
}

float3 GenPosition(uint i)
{
    float t = Random01(i + 1337u);

    return (1.0f - t) * _PrevSpawnPosition + t * _SpawnPosition;
}

float3 GenDirection(uint i)
{
    float t = Random01(i + 1337u);

    return (1.0f - t) * _PrevSpawnDirection + t * _SpawnDirection;
}

// Generate a random direction within a cone around the base direction
float3 RandomConeDirection(float3 baseDir, float coneAngle, uint seed)
{
    // Generate random point on a disk
    float angle = Random01(seed * 13u) * 6.28318530718f; // 2*PI
    float radius = Random01(seed * 17u);
    
    // Create perpendicular vectors to baseDir
    float3 up = abs(baseDir.y) < 0.99f ? float3(0, 1, 0) : float3(1, 0, 0);
    float3 right = normalize(cross(up, baseDir));
    float3 forward = cross(right, up);
    
    // Apply cone angle
    float spread = tan(coneAngle) * radius;
    float2 disk = float2(cos(angle), sin(angle)) * spread;
    
    float3 dir = normalize(baseDir + right * disk.x + forward * disk.y);
    return dir;
}

[numthreads(256,1,1)]
void Integrate(uint3 tid : SV_DispatchThreadID)
{
    uint i = tid.x;
    if (i >= (uint)_ActiveCount) return;

    Particle p = _Particles[i];

    bool isDead = (p.velocity.w < 0);

    if (isDead && (_EmitEnabled != 0) && (_SpawnBudget > 0))
    {
        uint prev;
        InterlockedAdd(_SpawnedCount[0], 1, prev); // atomic ticket
        if (prev < (uint)_SpawnBudget)
        {
            p.position.xyz = GenPosition(i + 17u);
            p.position.w = _SpawnRadius;
            
            // Get the base direction from brush motion
            float3 brushDir = GenDirection(i + 17u);
            
            // Blend brush direction with forward direction to reduce chaotic launches
            // forwardBias = 0 means pure brush direction, 1 means pure forward
            float3 blendedDir = lerp(brushDir, _ForwardDirection, _ForwardBias);
            float3 baseDir = normalize(blendedDir);
            
            // Create a cone of particles around the blended direction
            float3 dir = RandomConeDirection(baseDir, _SpreadAngle, i);
            
            // Speed variation: 0.5 to 1.0 of max speed for natural variation
            float spd = (0.5f + Random01(i + 11u) * 0.5f) * _MaxInitialSpeed;

            p.velocity.xyz = dir * spd;
            p.velocity.w   = 0; // age = 0 => alive now

            p.color = float4(_SpawnColor, 1.0f);
        }
        else
        {
            // budget exhausted; keep it dead and tiny
            p.position.w = 0;      // radius 0 => invisible
            _Particles[i] = p;
            return;
        }
    }

    // If still dead, just ensure invisible and skip work
    if (p.velocity.w < 0)
    {
        p.position.w = 0;          // invisible
        _Particles[i] = p;
        return;
    }

    // alive update
    // age & lifetime
    p.velocity.w += _DeltaTime;    // age
    if (p.velocity.w >= _LifeTime)
    {
        p.velocity.w = -1;
        p.position.w = 0;
        _Particles[i] = p;
        return;
    }

    // Calculate fade based on age
    float timeRemaining = _LifeTime - p.velocity.w;
    float fadeStart = _FadeOutDuration;
    if (timeRemaining < fadeStart && fadeStart > 0)
    {
        // Fade from 1.0 to 0.0 during the last fadeStart seconds
        float fadeProgress = timeRemaining / fadeStart;
        p.color.w = fadeProgress;
    }
    else
    {
        p.color.w = 1.0f; // fully opaque
    }

    // gravity
    p.velocity.xyz += float3(0, _Gravity, 0) * _DeltaTime;
    
    // air resistance (drag) - creates smoother, more natural arcs
    p.velocity.xyz *= (1.0f - _AirResistance * _DeltaTime);

    const float3 dimensions = float3(0.7f, 0.4f, 0.02f) * 0.5f * 5.0f;
    if (p.position.x > -dimensions.x && p.position.x < dimensions.x &&
        p.position.y > -dimensions.y && p.position.y < dimensions.y &&
        p.position.z > -dimensions.z && p.position.z < dimensions.z)
    {
        // Hit canvas, stop moving
        p.velocity.x = 0;
        p.velocity.y = 0;
        p.velocity.z = 0;
    }
        

    // integrate
    p.position.xyz += p.velocity.xyz * _DeltaTime;

    // bounce AABB with damping
    //float3 half = _BoundsExtents;
    //float r = p.position.w;

    /*
    if (p.position.x < -half.x + r) { p.position.x = -half.x + r; p.velocity.x *= -_Damping; }
    if (p.position.x >  half.x - r) { p.position.x =  half.x - r; p.velocity.x *= -_Damping; }

    if (p.position.y < -half.y + r) { p.position.y = -half.y + r; p.velocity.y *= -_Damping; }
    if (p.position.y >  half.y - r) { p.position.y =  half.y - r; p.velocity.y *= -_Damping; }

    if (p.position.z < -half.z + r) { p.position.z = -half.z + r; p.velocity.z *= -_Damping; }
    if (p.position.z >  half.z - r) { p.position.z =  half.z - r; p.velocity.z *= -_Damping; }
    */

    _Particles[i] = p;
}
